```js
import store from "@/store";  
  
export const encrypt = (value) => {  
    if (store.state.common.anonymousFlag) {  
        return desensitize(value)  
    }  
    return value;  
}  
  
/**  
 * 通用脱敏函数  
 * @param {string|number} input - 待脱敏内容  
 * @param {number} maskCount - 要替换（脱敏）的字符数，默认 4  
 * @param {Object} opts - 可选项  
 * @param {string} opts.maskChar - 用于替换的字符，默认 '*'  
 * @param {number} opts.keepLeft - 保留左侧多少字符（优先），默认 0  
 * @param {number} opts.keepRight - 保留右侧多少字符（优先），默认 0  
 * @returns {string}  
 */  
export const desensitize = (input, maskCount = 4, opts = {}) => {  
    const { maskChar = '*', keepLeft = 0, keepRight = 0 } = opts;  
    if (input === null || input === undefined) return '';  
    const s = String(input);  
  
    // 非正数或非整数的 maskCount 处理  
    maskCount = Math.max(0, Math.floor(Number(maskCount) || 0));  
  
    const n = s.length;  
    if (n === 0) return s;  
  
    // 如果显式指定保留左右，则按照保留规则优先计算  
    if (keepLeft > 0 || keepRight > 0) {  
        const left = Math.max(0, Math.floor(keepLeft));  
        const right = Math.max(0, Math.floor(keepRight));  
        // 可替换长度不能超过剩余长度  
        const maxMaskable = Math.max(0, n - left - right);  
        const maskedLen = Math.min(maskCount, maxMaskable);  
        if (maskedLen === 0) return s; // 无需脱敏或保留过多  
        return s.slice(0, left) + maskChar.repeat(maskedLen) + s.slice(n - right);  
    }  
  
    // 默认策略：在字符串中间替换 maskCount 个字符（向两侧平均保留）  
    if (maskCount <= 0) return s;  
    if (maskCount >= n) return maskChar.repeat(n);  
  
    const start = Math.floor((n - maskCount) / 2);  
    return s.slice(0, start) + maskChar.repeat(maskCount) + s.slice(start + maskCount);  
}
```

