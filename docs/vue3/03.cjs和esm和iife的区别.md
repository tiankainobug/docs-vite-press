在 JavaScript 模块化发展中，CJS、ESM、IIFE 是三种常见的模块格式（或打包输出格式），它们在语法、用途、运行环境等方面有显著区别，以下是详细解析：


### 1. CJS（CommonJS）
**定义**：CommonJS 是 Node.js 采用的模块化规范，主要用于服务器端（Node.js 环境），后来也被用于浏览器端（需通过打包工具转换）。

**核心语法**：
- **导出模块**：`module.exports` 或 `exports`
  ```javascript
  // 导出单个值
  module.exports = { name: 'cjs', version: 1 }
  
  // 导出多个值
  exports.foo = 'bar'
  exports.fn = () => {}
  ```
- **导入模块**：`require()`
  ```javascript
  const mod = require('./module.js')
  const { foo } = require('./module.js')
  ```

**特点**：
- **运行时加载**：模块加载是同步的，`require()` 会直接执行模块代码并返回导出结果，适合服务器端（文件读取快，同步加载影响小）。
- **动态导入**：`require()` 可以写在条件语句中（如 `if (condition) { require('./a') }`），支持动态路径。
- **值拷贝**：导入的是模块导出值的拷贝（原始类型是值拷贝，引用类型是地址拷贝），模块内部后续修改不会影响已导入的值。
- **模块缓存**：第一次 `require` 会缓存模块结果，后续导入直接复用缓存，避免重复执行。

**适用场景**：
- Node.js 原生环境（服务器端开发）。
- 早期浏览器端项目（需通过 Webpack、Browserify 等工具打包转换为浏览器可识别的代码）。


### 2. ESM（ECMAScript Module）
**定义**：ESM 是 ES6（2015）标准化的官方模块系统，同时支持浏览器和 Node.js（Node.js 需通过 `.mjs` 扩展名或 `package.json "type": "module"` 启用）。

**核心语法**：
- **导出模块**：`export`（命名导出）或 `export default`（默认导出）
  ```javascript
  // 命名导出
  export const name = 'esm'
  export function fn() {}
  
  // 默认导出
  export default { version: 1 }
  ```
- **导入模块**：`import`
  ```javascript
  // 导入命名导出
  import { name, fn } from './module.js'
  
  // 导入默认导出
  import mod from './module.js'
  
  // 混合导入
  import mod, { name } from './module.js'
  ```

**特点**：
- **编译时加载**：模块加载是静态的，`import` 语句必须放在模块顶部（不能在条件语句中），解析阶段就会确定依赖关系，支持 Tree-Shaking（摇树优化，剔除未使用的代码）。
- **值引用**：导入的是模块导出值的“实时引用”，模块内部修改后，导入方会同步更新（类似指针指向原始值）。
- **异步加载**：浏览器中通过 `<script type="module">` 加载 ESM 时，默认是异步的（不会阻塞 HTML 解析）。
- **严格模式**：ESM 模块自动运行在严格模式（`use strict`）下，禁止未声明变量、`with` 语句等。

**适用场景**：
- 现代浏览器端开发（直接支持 `<script type="module">`）。
- 现代 Node.js 项目（`"type": "module"` 配置）。
- 主流前端工程化项目（Webpack、Vite 等工具默认优先处理 ESM，支持 Tree-Shaking 优化）。


### 3. IIFE（Immediately Invoked Function Expression）
**定义**：IIFE 是“立即执行函数表达式”，并非模块化规范，而是一种代码封装模式，主要用于浏览器端避免全局变量污染，也是早期前端打包工具（如 Rollup、Webpack）的输出格式之一。

**核心语法**：
通过匿名函数自执行，将代码包裹在独立作用域中，通过暴露全局变量供外部使用：
```javascript
// 基本形式
(function(window) {
  const name = 'iife'
  function fn() {}
  // 暴露到全局
  window.myModule = { name, fn }
})(window)
```

**特点**：
- **无模块化语法**：没有显式的 `import/export`，通过全局变量（如 `window`）传递依赖和暴露接口。
- **立即执行**：代码加载后立即执行，作用域隔离（避免污染全局变量）。
- **兼容性好**：兼容所有浏览器（无需任何模块化支持），是早期前端代码的主要组织方式。

**适用场景**：
- 简单的浏览器端脚本（无需复杂模块依赖）。
- 库/工具的 UMD 格式基础（UMD 通常会同时兼容 CJS、AMD 和 IIFE，通过判断环境选择执行方式）。
- 打包工具输出的“自包含”脚本（如给非模块化环境使用的独立 JS 文件）。


### 三者对比总结
| 维度         | CJS                  | ESM                  | IIFE                  |
|--------------|----------------------|----------------------|-----------------------|
| 环境支持     | Node.js 原生         | 现代浏览器、Node.js  | 所有浏览器            |
| 加载方式     | 运行时同步加载       | 编译时静态加载       | 立即执行              |
| 语法         | `require`/`module.exports` | `import`/`export`    | 无模块语法（全局变量） |
| 依赖处理     | 动态（支持条件加载） | 静态（编译时确定）   | 手动通过全局变量传递  |
| 优化支持     | 不支持 Tree-Shaking  | 支持 Tree-Shaking    | 无优化                |
| 典型用途     | Node.js 后端         | 现代前端/后端项目    | 简单脚本、兼容性输出  |


在实际开发中，ESM 是目前的主流趋势（前端工程化和现代 Node.js 均优先支持），CJS 主要用于维护旧 Node.js 项目，IIFE 则多用于兼容性场景或简单脚本。打包工具（如 Rollup、Webpack）通常可根据配置输出任意格式（例如库文件常输出 ESM + CJS + IIFE 多种格式以适配不同环境）。